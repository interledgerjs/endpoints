{"version":3,"file":"stream.js","sourceRoot":"","sources":["../src/stream.ts"],"names":[],"mappings":"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","sourcesContent":["import { Duplex } from 'stream'\nimport { IlpMessage, serializeIlpMessage, isIlpMessage } from './message'\n\n/**\n * Wraps a byte stream and converts it into an object stream reading/writing `IlpMessage` objects.\n */\nexport class IlpMessageStream extends Duplex {\n\n  protected _stream: Duplex\n  protected _buffering: boolean\n  protected _buffer: Array<IlpMessage>\n\n  protected _readBuffer: Buffer\n  protected _readCursor: number\n\n  constructor (stream: Duplex) {\n    super({\n      allowHalfOpen: false,\n      objectMode: true\n    })\n\n    this._readBuffer = Buffer.allocUnsafe(0)\n    this._readCursor = 0\n\n    this._stream = stream\n\n    this._buffering = false\n    this._buffer = new Array()\n\n    this._stream.on('close', () => {\n      this.destroy()\n    })\n\n    this._stream.on('end', () => {\n      while (this._buffer.length > 0) {\n        this.push(this._buffer.shift())\n      }\n      this.push(null)\n      this.emit('end')\n      this.destroy()\n    })\n\n    this._stream.on('error', (err: Error) => {\n      this._stream.destroy()\n      this.destroy(err)\n    })\n\n    this._stream.on('data', (chunk: any) => {\n      if (Buffer.isBuffer(chunk)) {\n        this._readChunk(chunk)\n      } else {\n        this.destroy(new Error('unexpected type read from underlying stream'))\n      }\n    })\n  }\n\n  private _readChunk (chunk: Buffer) {\n    this._readBuffer = getReadBuffer(this._readBuffer, this._readCursor, chunk)\n    this._readCursor = 0\n\n    let messageSize = getMessageSize(this._readBuffer, this._readCursor)\n    while (messageSize !== undefined && this._readBuffer.length >= messageSize) {\n      const message = {\n        batch: this._readBuffer.readUInt32BE(this._readCursor),\n        id: this._readBuffer.readUInt32BE(this._readCursor + 4),\n        payload: this._readBuffer.slice(this._readCursor + 8, this._readCursor + messageSize)\n      }\n      if (this._buffering) {\n        this._buffer.push(message)\n      } else {\n        this._buffering = !(this.push(message))\n      }\n\n      this._readCursor += messageSize\n      messageSize = getMessageSize(this._readBuffer, this._readCursor)\n    }\n  }\n\n  _write (chunk: any, encoding: string, callback: (error?: Error | null) => void): void {\n    if (isIlpMessage(chunk)) {\n      this._stream.write(serializeIlpMessage(chunk), callback)\n    } else {\n      callback(new Error('unexpected message type.'))\n    }\n  }\n\n  _read (size: number) {\n    if (this._buffering) {\n      this._buffering = false\n      while (this._buffer.length > 0 && !this._buffering) {\n        this._buffering = !(this.push(this._buffer.shift()))\n      }\n    }\n  }\n\n  _destroy (error: Error | null, callback: (error: Error | null) => void): void {\n    try {\n      this._stream.destroy((error !== null) ? error : undefined)\n      callback(null)\n    } catch (e) {\n      callback(e)\n    }\n  }\n\n  _final (callback: (error?: Error | null) => void): void {\n    try {\n      this._stream.end(callback)\n    } catch (e) {\n      callback(e)\n    }\n  }\n\n}\n\n/**\n * Given an old buffer of data, the last position of the cursor and a new chunk of data, return a new buffer that contains any unread data from the old buffer followed by the new data.\n *\n * @param buffer The read buffer from the last read operation\n * @param cursor The position of the cursor after the last read operation\n * @param chunk The new data to be added to the buffer\n */\nexport function getReadBuffer (buffer: Buffer, cursor: number, chunk: Buffer): Buffer {\n  const unreadBytes = getUnreadByteCount(buffer, cursor)\n  if (unreadBytes > 0) {\n    const newBuffer = Buffer.allocUnsafe(unreadBytes + chunk.length)\n    buffer.copy(newBuffer, 0, cursor)\n    chunk.copy(newBuffer, unreadBytes, 0)\n    return newBuffer\n  } else {\n    return chunk\n  }\n}\n\nfunction getUnreadByteCount (buffer: Buffer, cursor: number) {\n  return buffer.length - cursor\n}\n\n/**\n * Calculates the byte size of the next message that will be read from the buffer.\n *\n * If there is not enough data in the buffer to read a complete message it returns `undefined`\n *\n * @param buffer read buffer\n * @param cursor read cursor\n */\nexport function getMessageSize (buffer: Buffer, cursor: number): number | undefined {\n  const LENGTH_OFFSET = 9\n  const unreadByteCount = getUnreadByteCount(buffer, cursor)\n  if (unreadByteCount > LENGTH_OFFSET) {\n    const length = buffer[cursor + LENGTH_OFFSET]\n    if ((length & 0x80) === 0x80) {\n      const lengthOfLength = length & 0x7f\n      if (lengthOfLength === 0) {\n        return undefined\n      }\n      if (unreadByteCount > (LENGTH_OFFSET + 1 + lengthOfLength)) {\n        const actualLength = buffer.readUIntBE(cursor + LENGTH_OFFSET + 1, lengthOfLength)\n        if (actualLength < 0x80) {\n          return undefined\n        }\n        if (unreadByteCount >= LENGTH_OFFSET + 1 + lengthOfLength + actualLength) {\n          return LENGTH_OFFSET + 1 + lengthOfLength + actualLength\n        }\n      }\n      return undefined\n    }\n    if (unreadByteCount >= LENGTH_OFFSET + 1 + length) {\n      return LENGTH_OFFSET + 1 + length\n    }\n  }\n  return undefined\n}\n"]}