{"version":3,"file":"frame.js","sourceRoot":"","sources":["../src/frame.ts"],"names":[],"mappings":";;AAmBa,QAAA,iBAAiB,GAAG,CAAC,CAAA;AAYlC,SAAgB,cAAc,CAAmB,MAAW,EAC1D,SAA+C,EAC/C,OAA2C;IAE3C,OAAO,CAAC,OAAO,MAAM,CAAC,EAAE,KAAK,QAAQ,CAAC;WACjC,CAAC,OAAO,MAAM,CAAC,OAAO,KAAK,WAAW,CAAC;WACvC,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,CAAA;AAC7C,CAAC;AAPD,wCAOC;AAQD,SAAgB,qBAAqB,CAAmB,KAAmC,EACzF,MAA4C;IAE5C,MAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;IACrC,MAAM,MAAM,GAAG,MAAM,CAAC,WAAW,CAAC,yBAAiB,GAAG,OAAO,CAAC,MAAM,CAAC,CAAA;IACrE,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,CAAA;IACjC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,yBAAiB,CAAC,CAAA;IACvC,OAAO,MAAM,CAAA;AACf,CAAC;AARD,sDAQC;AAQD,SAAgB,uBAAuB,CAAmB,IAAY,EACpE,MAA4C;IAE5C,OAAO;QACL,EAAE,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;QACxB,OAAO,EAAE,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,yBAAiB,CAAC,CAAC;KAC/C,CAAA;AACH,CAAC;AAPD,0DAOC","sourcesContent":["/**\n * The message frame for exchanging messages over a byte stream.\n *\n * Each frame has a 32-bit identifier which is used to match a request with a subsequent reply.\n *\n * The payload of the message is an OER encoded ILP packet.\n */\nexport interface MessageFrame<Request, Reply> {\n\n  /**\n   * The message identifier decoded as an unsigned 32-bit integer (Big Endian)\n   */\n  id: number\n  /**\n   * The message payload\n   */\n  payload: Request | Reply\n}\n\nexport const MESSAGE_ID_LENGTH = 4\n\nexport type MessageFrameTypeGuard <Request, Reply> = (object: any) => object is MessageFrame<Request, Reply>\nexport type Encoder<Request, Reply> = (object: Request | Reply) => Buffer\nexport type Decoder<Request, Reply> = (object: Buffer) => Request | Reply\n/**\n * Test if an object is a valid frame\n *\n * @param object object to test\n * @param isRequest a function to test if the payload is a valid request\n * @param isReply a function to test if the payload is a valid reply\n */\nexport function isMessageFrame <Request, Reply> (object: any,\n  isRequest: (request: any) => request is Request,\n  isReply: (request: any) => request is Reply): object is MessageFrame<Request, Reply> {\n\n  return (typeof object.id === 'number')\n    && (typeof object.payload !== 'undefined')\n    && (isRequest(object) || isReply(object))\n}\n\n/**\n * Serialize an frame into a Buffer\n *\n * @param frame A MessageFrame object\n * @param encode a function to encode the payload\n */\nexport function serializeMessageFrame <Request, Reply> (frame: MessageFrame<Request, Reply>,\n  encode: (payload: Request | Reply) => Buffer): Buffer {\n\n  const payload = encode(frame.payload)\n  const buffer = Buffer.allocUnsafe(MESSAGE_ID_LENGTH + payload.length)\n  buffer.writeUInt32BE(frame.id, 0)\n  payload.copy(buffer, MESSAGE_ID_LENGTH)\n  return buffer\n}\n\n/**\n * Deserialize a frame from a Buffer\n *\n * @param data the Buffer containing a serialized MessageFrame\n * @param decode a function to decode the payload\n */\nexport function deserializeMessageFrame <Request, Reply> (data: Buffer,\n  decode: (payload: Buffer) => Request | Reply): MessageFrame<Request, Reply> {\n\n  return {\n    id: data.readUInt32BE(0),\n    payload: decode(data.slice(MESSAGE_ID_LENGTH))\n  }\n}\n"]}