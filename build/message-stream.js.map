{"version":3,"file":"message-stream.js","sourceRoot":"","sources":["../src/message-stream.ts"],"names":[],"mappings":"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","sourcesContent":["import { Duplex, Transform, TransformOptions, TransformCallback } from 'stream'\nimport { MessageFrame, serializeMessageFrame, isMessageFrame, MESSAGE_ID_LENGTH, MessageFrameTypeGuard, Encoder, Decoder } from './frame'\nimport { ReadableRequestStream } from './request-stream'\n\n// /**\n//  * Wraps a byte stream and converts it into an object stream reading/writing `MessageFrame` objects.\n//  */\n// export class MessageStream extends Duplex {\n\n//   protected _stream: Duplex\n//   protected _buffering: boolean\n//   protected _buffer: Array<MessageFrame>\n\n//   protected _readBuffer: Buffer\n//   protected _readCursor: number\n\n//   constructor (byteStream: Duplex) {\n//     super({\n//       allowHalfOpen: false,\n//       objectMode: true\n//     })\n\n//     this._readBuffer = Buffer.allocUnsafe(0)\n//     this._readCursor = 0\n\n//     this._stream = byteStream\n\n//     this._buffering = false\n//     this._buffer = new Array()\n\n//     this._stream.on('close', () => {\n//       this.destroy()\n//     })\n\n//     this._stream.on('end', () => {\n//       while (this._buffer.length > 0) {\n//         this.push(this._buffer.shift())\n//       }\n//       this.push(null)\n//       this.emit('end')\n//       this.destroy()\n//     })\n\n//     this._stream.on('error', (err: Error) => {\n//       this._stream.destroy()\n//       this.destroy(err)\n//     })\n\n//     this._stream.on('data', (chunk: any) => {\n//       if (Buffer.isBuffer(chunk)) {\n//         this._readChunk(chunk)\n//       } else {\n//         this.destroy(new Error('unexpected type read from underlying stream'))\n//       }\n//     })\n//   }\n\n//   private _readChunk (chunk: Buffer) {\n//     this._readBuffer = getReadBuffer(this._readBuffer, this._readCursor, chunk)\n//     this._readCursor = 0\n\n//     let messageSize = getMessageSize(this._readBuffer, this._readCursor)\n//     while (messageSize !== undefined && this._readBuffer.length >= messageSize) {\n//       const message = {\n//         id: this._readBuffer.readUInt32BE(this._readCursor),\n//         payload: this._readBuffer.slice(this._readCursor + 4, this._readCursor + messageSize)\n//       }\n//       if (this._buffering) {\n//         this._buffer.push(message)\n//       } else {\n//         this._buffering = !(this.push(message))\n//       }\n\n//       this._readCursor += messageSize\n//       messageSize = getMessageSize(this._readBuffer, this._readCursor)\n//     }\n//   }\n\n//   _write (chunk: any, encoding: string, callback: (error?: Error | null) => void): void {\n//     if (isMessageFrame(chunk)) {\n//       this._stream.write(serializeMessageFrame(chunk), callback)\n//     } else {\n//       callback(new Error('unexpected message type.'))\n//     }\n//   }\n\n//   _read (size: number) {\n//     if (this._buffering) {\n//       this._buffering = false\n//       while (this._buffer.length > 0 && !this._buffering) {\n//         this._buffering = !(this.push(this._buffer.shift()))\n//       }\n//     }\n//   }\n\n//   _destroy (error: Error | null, callback: (error: Error | null) => void): void {\n//     try {\n//       this._stream.destroy((error !== null) ? error : undefined)\n//       callback(null)\n//     } catch (e) {\n//       callback(e)\n//     }\n//   }\n\n//   _final (callback: (error?: Error | null) => void): void {\n//     try {\n//       this._stream.end(callback)\n//     } catch (e) {\n//       callback(e)\n//     }\n//   }\n\n// }\n\n/**\n * Decodes a MessageFrame\n */\nexport class MessageDecoder<Request,Reply> extends Transform {\n  constructor (decode: Decoder<Request, Reply>, isMessage: MessageFrameTypeGuard<Request, Reply>) {\n    let _readBuffer = Buffer.allocUnsafe(0)\n    let _readCursor = 0\n    super({\n      allowHalfOpen: false,\n      readableObjectMode: true,\n      transform (chunk: any, encoding: string, callback: TransformCallback): void {\n        if (Buffer.isBuffer(chunk)) {\n          _readBuffer = getReadBuffer(_readBuffer, _readCursor, chunk)\n          _readCursor = 0\n\n          let messageSize = getMessageSize(_readBuffer, _readCursor)\n          while (messageSize !== undefined && _readBuffer.length >= messageSize) {\n            const message = {\n              id: _readBuffer.readUInt32BE(_readCursor),\n              payload: decode(_readBuffer.slice(_readCursor + MESSAGE_ID_LENGTH, _readCursor + messageSize))\n            }\n            if (isMessage(message)) {\n              this.push(message)\n            } else {\n              this.emit('error', new Error('invalid object decoded from underlying stream. ' + JSON.stringify(message)))\n            }\n            _readCursor += messageSize\n            messageSize = getMessageSize(_readBuffer, _readCursor)\n          }\n          callback()\n        } else {\n          this.destroy(new Error('unexpected type read from underlying stream'))\n        }\n      }\n    })\n  }\n}\n\n/**\n * Encodes a MessageFrame\n */\nexport class MessageEncoder<Request, Reply> extends Transform {\n  constructor (encode: Encoder<Request, Reply>, isMessage: MessageFrameTypeGuard<Request, Reply>) {\n    super({\n      allowHalfOpen: false,\n      writableObjectMode: true,\n      transform (chunk: any, encoding: string, callback: TransformCallback): void {\n        if (isMessage(chunk)) {\n          this.push(serializeMessageFrame(chunk, encode))\n        } else {\n          callback(new Error('unexpected message type.'))\n        }\n      }\n    })\n  }\n}\n\n/**\n * Given an old buffer of data, the last position of the cursor and a new chunk of data, return a new buffer that contains any unread data from the old buffer followed by the new data.\n *\n * @param buffer The read buffer from the last read operation\n * @param cursor The position of the cursor after the last read operation\n * @param chunk The new data to be added to the buffer\n */\nexport function getReadBuffer (buffer: Buffer, cursor: number, chunk: Buffer): Buffer {\n  const unreadBytes = getUnreadByteCount(buffer, cursor)\n  if (unreadBytes > 0) {\n    const newBuffer = Buffer.allocUnsafe(unreadBytes + chunk.length)\n    buffer.copy(newBuffer, 0, cursor)\n    chunk.copy(newBuffer, unreadBytes, 0)\n    return newBuffer\n  } else {\n    return chunk\n  }\n}\n\nfunction getUnreadByteCount (buffer: Buffer, cursor: number) {\n  return buffer.length - cursor\n}\n\n/**\n * Calculates the byte size of the next message that will be read from the buffer.\n *\n * If there is not enough data in the buffer to read a complete message it returns `undefined`\n *\n * @param buffer read buffer\n * @param cursor read cursor\n */\nexport function getMessageSize (buffer: Buffer, cursor: number): number | undefined {\n  const LENGTH_OFFSET = 5\n  const unreadByteCount = getUnreadByteCount(buffer, cursor)\n  if (unreadByteCount > LENGTH_OFFSET) {\n    const length = buffer[cursor + LENGTH_OFFSET]\n    if ((length & 0x80) === 0x80) {\n      const lengthOfLength = length & 0x7f\n      if (lengthOfLength === 0) {\n        return undefined\n      }\n      if (unreadByteCount > (LENGTH_OFFSET + 1 + lengthOfLength)) {\n        const actualLength = buffer.readUIntBE(cursor + LENGTH_OFFSET + 1, lengthOfLength)\n        if (actualLength < 0x80) {\n          return undefined\n        }\n        if (unreadByteCount >= LENGTH_OFFSET + 1 + lengthOfLength + actualLength) {\n          return LENGTH_OFFSET + 1 + lengthOfLength + actualLength\n        }\n      }\n      return undefined\n    }\n    if (unreadByteCount >= LENGTH_OFFSET + 1 + length) {\n      return LENGTH_OFFSET + 1 + length\n    }\n  }\n  return undefined\n}\n"]}