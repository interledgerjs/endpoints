{"version":3,"file":"socket.js","sourceRoot":"","sources":["../src/socket.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ResponseFrame,\n  ErrorFrame,\n  Frame,\n  isRequest,\n  deserializeFrame,\n  RequestFrame,\n  ReplyFrame,\n  serializeFrame,\n  FrameHeaders\n} from './packet' \nimport { SError } from 'verror'\nimport { Request } from './request'\nimport { EventEmitter } from 'events'\nimport { AccountInfo } from './account'\nimport { default as createLogger, Logger } from 'ilp-logger'\nimport { IlpPrepare, IlpReply, isReject, serializeIlpPacket } from 'ilp-packet';\nimport { Socket, createConnection as createNetSocket, NetConnectOpts, AddressInfo } from 'net';\nimport { codes as IlpErrorCodes } from 'ilp-packet/dist/src/errors';\nconst log = createLogger('grpc-transport')\n\nexport const ILP_TCP_URL_PROTOCOL = 'ilp+tcp:'\nexport const ILP_IPC_URL_PROTOCOL = 'ilp+ipc:'\n\nexport interface IlpSession {\n  accountId: string\n  accountInfo: AccountInfo\n  localIlpAddress: string\n  currentBatch: number\n}\n\nexport class IlpSocket extends EventEmitter {\n  protected _log: Logger\n  protected _socket: Socket\n  protected _requestIdsByBatch: Map<number, number>\n  protected _requests: Map<string, Request>\n  protected _requestHandler?: (batch: number, message: IlpPrepare) => Promise<IlpReply>\n\n  constructor (socket: Socket) {\n    super()\n    this._socket = socket\n    this._requests = new Map()\n\n    this._socket.on('data', (data: Buffer) => {\n      this._handleData(data)\n    })\n\n    this._socket.on('close', () => {\n      this.emit('close')\n    })\n\n    this._socket.on('error', (error: any) => {\n      this.emit('error', error)\n    })\n  }\n\n  public session?: IlpSession\n\n  public address(): AddressInfo & { ilpAddress: string} {\n    const { address, port, family} = this._socket.address() as AddressInfo\n    return {\n      address,\n      port, \n      family: 'ILPv4+' + family,\n      ilpAddress: this.session ? this.session.localIlpAddress :  'self'\n    }\n  }\n\n  /**\n   * Send a Request and wait for the Reply.\n   *\n   * @param message Message to send\n   */\n  public request (message: IlpPrepare, sentCallback?: () => void): Promise<IlpReply> {\n    return new Promise<IlpReply>((replyCallback, errorCallback) => {\n      const frameHeader = this._nextFrameHeaders()\n      const key = _requestKey(frameHeader)\n      const frame = Object.assign(frameHeader, message)\n      this._requests.set(key, new Request(\n        frame, \n        (response: ReplyFrame) => {\n          this._requests.delete(key)\n          replyCallback(response)\n        },\n        () => {\n          this._requests.delete(key)\n          errorCallback(new SError('timed out waiting for response'))\n        }))\n      this._socket.write(serializeFrame(frame), sentCallback)\n    })\n  }\n\n  private _nextFrameHeaders(): FrameHeaders {\n    const batch = (this.session) ? this.session.currentBatch : 1\n    const oldId = this._requestIdsByBatch.get(batch)\n    const id = (typeof oldId !== 'number') ? 0 : oldId + 2\n    this._requestIdsByBatch.set(batch, id)\n    return { id, batch }\n  }\n\n  private _handleData (data: Buffer): void {\n    try {\n      const frame = deserializeFrame(data)\n      if (isRequest(frame)) {\n        this._handleRequest(frame)\n      } else {\n        this._handleReply(frame)\n      }\n    } catch (e) {\n      log.trace('Handle Data Error', data)\n      this.emit('error', new SError(e, `Unable to deserialize frame: ${data.toString('hex')}`))\n    }\n  }\n\n  private _handleRequest (frame: RequestFrame): void {\n\n    if(this._requestHandler) {\n      this._requestHandler(frame.batch, frame)\n      .then( reply => {\n        this._socket.write(serializeFrame(Object.assign(\n          {\n            id: frame.id | 1,\n            batch: frame.batch,\n          }, \n          reply\n        )))  \n      })\n      .catch( e => {\n        // Error thrown by request handler\n        this.emit('error', e)\n        this._socket.write(serializeFrame({\n          id: frame.id | 1,\n          batch: frame.batch,\n          triggeredBy: this.address().ilpAddress,\n          code: IlpErrorCodes.T00_INTERNAL_ERROR,\n          message: '',\n          data: Buffer.allocUnsafe(0)\n        }))\n      })\n    } else {\n      // No request handler for request\n      this.emit('error', new SError('no request handler registered for incoming request: %s', frame))\n      this._socket.write(serializeFrame({\n        id: frame.id | 1,\n        batch: frame.batch,\n        triggeredBy: this.address().ilpAddress,\n        code: IlpErrorCodes.T01_PEER_UNREACHABLE,\n        message: '',\n        data: Buffer.allocUnsafe(0)\n      }))\n    }\n  }\n\n  private _handleReply (frame: ReplyFrame): void {\n    const originalRequest = this._requests.get(_requestKey(frame))\n    if (!originalRequest) {\n      this.emit('error', new SError('unsolicited response message received: %s', frame))\n    } else {\n      originalRequest.responseReceived(frame)\n    }\n  } \n}\n\nfunction _requestKey(headers: FrameHeaders): string {\n  const {id, batch} = headers\n  const buffer = Buffer.allocUnsafe(8)\n  buffer.writeInt32BE(id & 0, 0)\n  buffer.writeInt32BE(batch, 4)\n  return buffer.toString('hex')\n}\n\n\nexport async function authenticateWithPeer (socket: IlpSocket, accountId: string, secret: string): Promise<void> {\n  const rsp = await this.request(0, {\n    destination: 'peer.auth',\n    amount: '0',\n    executionCondition: Buffer.allocUnsafe(32), // TODO - Use correct condition\n    expiresAt: new Date(Date.now() + 30 * 1000),\n    data: Buffer.from(accountId, 'utf8') // TODO - Define an auth protocol\n  })\n\n  if(isReject(rsp)) {\n    throw new Error('Auth rejected') // TODO - Use correct error\n  }\n  const result = JSON.parse(rsp.data.toString('utf8')) // TODO - parse return values\n\n}\n\nexport async function createConnection (url: URL, createSession?: (socket: IlpSocket) => Promise<void>): Promise<IlpSocket> {\n\n  const accountId = url.username\n  const accountSecret = url.password\n  return new Promise<IlpSocket>((resolve, reject) => {\n\n    async function handleConnect (socket: Socket) {\n      const ilpSocket = new IlpSocket(socket)\n      if(accountId || accountSecret) {\n        await authenticateWithPeer(ilpSocket, accountId, accountSecret)\n      }\n      if(createSession) {\n        await createSession(ilpSocket)\n      }\n      return ilpSocket\n    }\n\n    if (url.protocol === ILP_TCP_URL_PROTOCOL) {\n      const tcpSocket = createNetSocket(Number(url.port), url.hostname, () => {\n        handleConnect(tcpSocket)\n      })\n    } else if (url.protocol === ILP_IPC_URL_PROTOCOL) {\n      const ipcSocket = createNetSocket(url.pathname, () => {\n        handleConnect(ipcSocket)\n      })\n    } else {\n      throw new Error(`Unknown protocol: ${url.protocol}`)\n    }\n  \n  })\n}\n"]}