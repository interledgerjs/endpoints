{"version":3,"file":"request-stream.js","sourceRoot":"","sources":["../src/request-stream.ts"],"names":[],"mappings":";;AAuBA,SAAgB,QAAQ,CAAkB,GAAG,qBAAyE;IACpH,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACzD,MAAM,gBAAgB,GAAG,qBAAqB,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAA;QAC1D,MAAM,gBAAgB,GAAG,qBAAqB,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAA;QAC9D,MAAM,gBAAgB,GAAG,qBAAqB,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAA;QAC9D,MAAM,gBAAgB,GAAG,qBAAqB,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAA;QAC1D,gBAAgB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAA;QACvC,gBAAgB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAA;KACxC;IACD,OAAO;QACL,QAAQ,EAAE;YACR,KAAK,EAAE,CAAC,OAAO,EAAE,EAAE;gBACjB,OAAO,qBAAqB,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;YACzD,CAAC;YACD,IAAI,EAAE,CAAC,QAA+C,EAAE,EAAE;gBACxD,OAAO,qBAAqB,CAAC,qBAAqB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;YACxF,CAAC;YACD,MAAM,EAAE,GAAG,EAAE;gBACX,OAAO,qBAAqB,CAAC,qBAAqB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAA;YAClF,CAAC;SACF;QACD,QAAQ,EAAE;YACR,KAAK,EAAE,CAAC,OAAO,EAAE,EAAE;gBACjB,OAAO,qBAAqB,CAAC,qBAAqB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;YACxF,CAAC;YACD,IAAI,EAAE,CAAC,QAA+C,EAAE,EAAE;gBACxD,OAAO,qBAAqB,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;YACzD,CAAC;YACD,MAAM,EAAE,GAAG,EAAE;gBACX,OAAO,qBAAqB,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAA;YACnD,CAAC;SACF;KACF,CAAA;AACH,CAAC;AAjCD,4BAiCC","sourcesContent":["/**\n * This module defines interfaces modelled on Node's native stream interfaces but for\n * request/response pairs.\n *\n * The difference is therefor that when writing to a `WritableRequestStream` the writer is returned\n * a Promise that will resolve to a reply.\n *\n * The current version of the interfaces assumes that implementations are not buffering so functions such as\n * `pause` and `resume` and properties such as `readable`, `writable` etc. are not defined.\n */\n\n /**\n  * A request handler takes a request and asynchronously returns a reply.\n  */\nexport type RequestHandler<Request, Reply> = (request: Request) => Promise<Reply>\n\n/**\n * Connect a pipeline of bidirectional duplex streams together.\n *\n * Returns a new bidirectional duplex that is the combination of the provided bidirectional duplexes.\n *\n * @param bidirectionalDuplexes an ordered collection of bidirectional duplexes to connect together\n */\nexport function pipeline<Request, Reply> (...bidirectionalDuplexes: BidirectionalDuplexRequestStream<Request, Reply>[]): BidirectionalDuplexRequestStream<Request, Reply> {\n  for (let i = 0; i + 1 < bidirectionalDuplexes.length; i++) {\n    const incomingReadable = bidirectionalDuplexes[i].incoming\n    const incomingWritable = bidirectionalDuplexes[i + 1].incoming\n    const outgoingReadable = bidirectionalDuplexes[i + 1].outgoing\n    const outgoingWritable = bidirectionalDuplexes[i].outgoing\n    incomingReadable.pipe(incomingWritable)\n    outgoingReadable.pipe(outgoingWritable)\n  }\n  return {\n    incoming: {\n      write: (request) => {\n        return bidirectionalDuplexes[0].incoming.write(request)\n      },\n      pipe: (writable: WritableRequestStream<Request, Reply>) => {\n        return bidirectionalDuplexes[bidirectionalDuplexes.length - 1].incoming.pipe(writable)\n      },\n      unpipe: () => {\n        return bidirectionalDuplexes[bidirectionalDuplexes.length - 1].incoming.unpipe()\n      }\n    },\n    outgoing: {\n      write: (request) => {\n        return bidirectionalDuplexes[bidirectionalDuplexes.length - 1].outgoing.write(request)\n      },\n      pipe: (writable: WritableRequestStream<Request, Reply>) => {\n        return bidirectionalDuplexes[0].outgoing.pipe(writable)\n      },\n      unpipe: () => {\n        return bidirectionalDuplexes[0].outgoing.unpipe()\n      }\n    }\n  }\n}\n\n/**\n * A component that has both incoming and an outgoing duplex request streams.\n */\nexport interface BidirectionalDuplexRequestStream<Request, Reply> {\n  incoming: DuplexRequestStream<Request, Reply>\n  outgoing: DuplexRequestStream<Request, Reply>\n}\n\n/**\n * A readable stream of requests.\n *\n * This is equivalent to a native readable that is always in `readable.readableFlowing === true` state.\n * i.e. There is no buffering and the only way to read is to pipe the output to a writable.\n */\nexport interface ReadableRequestStream<Request, Reply> {\n  pipe: (writable: WritableRequestStream<Request, Reply>) => this\n\n  unpipe: () => this\n}\n\n/**\n * A writable stream of requests.\n */\nexport interface WritableRequestStream<Request, Reply> {\n  write: RequestHandler<Request, Reply>\n}\n\n/**\n * A duplex stream of requests (implements both the readable and writeable interfaces)\n */\nexport type DuplexRequestStream<Request,Reply> = ReadableRequestStream<Request, Reply> & WritableRequestStream<Request, Reply>\n"]}