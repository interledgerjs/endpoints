{"version":3,"file":"stream-endpoint.js","sourceRoot":"","sources":["../src/stream-endpoint.ts"],"names":[],"mappings":"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","sourcesContent":["import { MessageFrame, isMessageFrame, MessageFrameTypeGuard } from './frame'\nimport { Endpoint } from './endpoint'\nimport { Duplex } from 'stream'\nimport { MessageDecoder, MessageEncoder } from './message-stream'\nimport { RequestHandler } from './request-stream'\n\nexport type ExpiringRequest = { expiresAt: Date }\n\nexport const DEFAULT_MAX_TIMEOUT_MS = 5 * 60 * 1000\n\nexport interface MessageStreamCodecs<Request, Reply> {\n  isMessage: MessageFrameTypeGuard<Request, Reply>,\n  encode: (payload: Request | Reply) => Buffer,\n  decode: (payload: Buffer) => Request | Reply,\n  isRequest (payload: any): payload is Request\n}\n\n/**\n * Constructor options for a new `StreamEndpoint` object.\n */\nexport interface StreamEndpointOptions<Request, Reply> {\n\n  /**\n   * The initial handler for incoming requests.\n   */\n  handler?: RequestHandler<Request, Reply>\n\n  /**\n   * The id to use for the next request.\n   *\n   * Subsequent requests will use an incrementally higher id until the id reaches 0xffffffff and then it will roll back to 0x00000001.\n   * The id 0 is never used to avoid unpredictable behaviour if the value is 'falsey'.\n   *\n   * If the provided value is > 0xffffffff it will be reset to 0x00000001\n   */\n  nextRequestId?: number\n  /**\n   * Max timeout allowed in ILP Prepare packets passed via `request`.\n   */\n  maxTimeoutMs?: number\n}\n\n/**\n * Reference implementation of an Endpoint that is also a `stream.Duplex`.\n *\n * The provided codecs are used to decode/encode data read/written to the Duplex\n */\nexport class StreamEndpoint<Request extends ExpiringRequest, Reply> extends Duplex implements Endpoint<Request, Reply> {\n  protected _outgoingMessageStream: Duplex\n  protected _incomingMessageStream: Duplex\n  protected _isRequest: (payload: any) => payload is Request\n  protected _isMessageFrame: MessageFrameTypeGuard<Request, Reply>\n  protected _nextRequestId: number\n  protected _outgoing: Map<number, { respond: (response: Reply) => void, timeout: NodeJS.Timeout }>\n  protected _incoming: Set<number>\n  protected _maxTimeoutMs: number\n  protected _incomingRequestHandler: RequestHandler<Request, Reply>\n\n  /**\n   * Create a new MessageStreamEndpoint using the provided stream as the underlying message stream.\n   *\n   * @param stream a stream.Duplex that reads/writes `MessageFrame` objects\n   * @param options constructor options\n   */\n  constructor (codecs: MessageStreamCodecs<Request, Reply>, options?: StreamEndpointOptions<Request, Reply>) {\n\n    super({\n      allowHalfOpen: false,\n      read: (): void => {\n        this._outgoingMessageStream.resume()\n      },\n      write: (chunk: any, encoding?: string, callback?: (error?: Error) => void): void => {\n        this._incomingMessageStream.write(chunk, encoding, callback)\n      }\n    })\n\n    this._isRequest = codecs.isRequest\n    this._isMessageFrame = codecs.isMessage\n    this._incoming = new Set()\n    this._outgoing = new Map()\n\n    if (options && options.nextRequestId) {\n      this._nextRequestId = options.nextRequestId\n      if (this._nextRequestId > 0xffffffff) {\n        this._nextRequestId = 1\n      }\n    } else {\n      this._nextRequestId = 1\n    }\n\n    this._maxTimeoutMs = (options && options.maxTimeoutMs)\n      ? options.maxTimeoutMs\n      : DEFAULT_MAX_TIMEOUT_MS\n\n    this._outgoingMessageStream = new MessageEncoder<Request, Reply>(codecs.encode, codecs.isMessage)\n    this._outgoingMessageStream.on('error', (error: any) => {\n      this.emit('error', error)\n    })\n    this._outgoingMessageStream.on('data', (chunk: any) => {\n      if (!this.push(chunk)) {\n        this._outgoingMessageStream.pause()\n      }\n    })\n\n    this._incomingMessageStream = new MessageDecoder<Request, Reply>(codecs.decode, codecs.isMessage)\n    this._incomingMessageStream.on('error', (error: any) => {\n      this.emit('error', error)\n    })\n    this._incomingMessageStream.on('data', async (message: MessageFrame<Request, Reply>) => {\n      return this._handleMessage(message)\n    })\n\n    if (options && options.handler) {\n      this._incomingRequestHandler = options.handler\n    } else {\n      this._incomingRequestHandler = (packet: Request): Promise<Reply> => {\n        throw new Error('no request handler for incoming request')\n      }\n    }\n  }\n\n  public sendOutgoingRequest (request: Request, sentCallback?: () => void): Promise<Reply> {\n    if (!this._outgoingMessageStream.writable) throw new Error('underlying stream is not writeable')\n    const message = this._nextMessage(request)\n    const timeoutMs = request.expiresAt.valueOf() - Date.now()\n    if (timeoutMs > this._maxTimeoutMs || timeoutMs <= 0) {\n      throw new Error(`invalid expiresAt in ILP packet. timeoutMs=${timeoutMs}, maxTimeoutMs=${this._maxTimeoutMs}`)\n    }\n    return new Promise<Reply>((replyCallback, errorCallback) => {\n      const timeout = setTimeout(() => {\n        this._outgoing.delete(message.id)\n        errorCallback(new Error('timed out waiting for response'))\n      }, timeoutMs)\n\n      const respond = (reply: Reply) => {\n        clearTimeout(timeout)\n        this._outgoing.delete(message.id)\n        replyCallback(reply)\n      }\n      this._outgoing.set(message.id, { respond, timeout })\n      this._outgoingMessageStream.write(message, sentCallback)\n    })\n  }\n\n  public setIncomingRequestHandler (handler: RequestHandler<Request, Reply>): this {\n    this._incomingRequestHandler = handler\n    return this\n  }\n\n  private _nextMessage (payload: Request | Reply): MessageFrame<Request, Reply> {\n    const id = this._nextRequestId++\n    if (this._nextRequestId > 0xffffffff) {\n      this._nextRequestId = 1\n    }\n    return { id, payload }\n  }\n\n  private async _handleMessage (message: MessageFrame<Request, Reply>): Promise<void> {\n    const { id, payload } = message\n    try {\n      if (this._isRequest(payload)) {\n\n        if (this._incoming.has(id)) {\n          this.emit('error', new Error(`duplicate request received for id: ${id}`))\n          return\n        }\n        this._incoming.add(id)\n\n        try {\n          const reply = await (async () => {\n            const timeout = setTimeout(() => {\n              throw new Error(`timed out waiting for response from request handler. id=${id}`)\n            }, payload.expiresAt.getMilliseconds() - new Date().getMilliseconds())\n            const reply = await this._incomingRequestHandler(payload)\n            clearTimeout(timeout)\n            return reply\n          })()\n\n          this._incomingMessageStream.write({ id, payload: reply }, (error?: Error) => {\n            if (error) {\n              this.emit('error', error)\n            }\n          })\n        } catch (e) {\n          this.emit('error', e)\n        } finally {\n          this._incoming.delete(id)\n        }\n      } else {\n        const request = this._outgoing.get(id)\n        if (!request) {\n          this.emit('error', new Error('unsolicited response message received: ' + JSON.stringify(message)))\n        } else {\n          request.respond(payload)\n        }\n      }\n    } catch (e) {\n      this.emit('error', e)\n    }\n  }\n}\n"]}