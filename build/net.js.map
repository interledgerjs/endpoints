{"version":3,"file":"net.js","sourceRoot":"","sources":["../src/net.ts"],"names":[],"mappings":"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","sourcesContent":["import { Duplex } from 'stream'\nimport { IlpMessage, deserializeIlpMessage, serializeIlpMessage, isIlpMessage } from './message'\n\n/**\n * Wraps a bytes stream and converts into object stream reading/writing `IlpMessage` objects.\n */\nexport class IlpMessageStream extends Duplex {\n\n  protected _stream: Duplex\n  protected _buffering: boolean\n  protected _buffer: Array<IlpMessage>\n\n  protected _readBuffer: Buffer\n  protected _readCursor: number\n\n  constructor (stream: Duplex) {\n    super({\n      allowHalfOpen: false,\n      objectMode: true\n    })\n\n    this._readBuffer = Buffer.allocUnsafe(0)\n    this._readCursor = 0\n\n    this._stream = stream\n\n    this._buffering = false\n    this._buffer = new Array()\n\n    this._stream.on('close', (code: number, reason: string) => {\n      this._end()\n    })\n\n    this._stream.on('error', (err: Error) => {\n      this.emit('error', err)\n    })\n\n    this._stream.on('data', (chunk: any) => {\n      if (Buffer.isBuffer(chunk)) {\n        this._readChunk(chunk)\n      } else {\n        this._stream.end()\n        this.emit('error', new Error('unexpected message type received'))\n        this._end()\n      }\n    })\n  }\n\n  private _end () {\n    while (this._buffer.length > 0) {\n      this.push(this._buffer.shift())\n    }\n    this.push(null)\n  }\n\n  private _readChunk (chunk: Buffer) {\n    this._readBuffer = getReadBuffer(this._readBuffer, this._readCursor, chunk)\n    this._readCursor = 0\n\n    let messageSize = getMessageSize(this._readBuffer, this._readCursor)\n    while (messageSize !== undefined && this._readBuffer.length >= messageSize) {\n      const message = {\n        batch: this._readBuffer.readUInt32BE(0),\n        id: this._readBuffer.readUInt32BE(4),\n        payload: this._readBuffer.slice(8, messageSize - 8)\n      }\n      if (this._buffering) {\n        this._buffer.push(message)\n      } else {\n        this._buffering = !(this.push(message))\n      }\n\n      this._readCursor += messageSize\n      messageSize = getMessageSize(this._readBuffer, this._readCursor)\n    }\n  }\n\n  _write (chunk: any, encoding: string, callback: (error?: Error | null) => void): void {\n    if (isIlpMessage(chunk)) {\n      this._stream.write(serializeIlpMessage(chunk), callback)\n    } else {\n      callback(new Error('unexpected message type.'))\n    }\n  }\n\n  _read (size: number) {\n    if (this._buffering) {\n      this._buffering = false\n      while (this._buffer.length > 0 && !this._buffering) {\n        this._buffering = !(this.push(this._buffer.shift()))\n      }\n    }\n  }\n\n  _destroy (error: Error | null, callback: (error: Error | null) => void): void {\n    this._stream.destroy((error !== null) ? error : undefined)\n    callback(error)\n  }\n\n  _final (callback: (error?: Error | null) => void): void {\n    try {\n      this._stream.end(callback)\n    } catch (e) {\n      callback(e)\n    }\n  }\n\n}\n\n/**\n * Given an old buffer of data, the last position of the cursor and a new chunk of data, return a new buffer that contains any unread data from the old buffer followed by the new data.\n *\n * @param buffer The read buffer from the last read operation\n * @param cursor The position of the cursor after the last read operation\n * @param chunk The new data to be added to the buffer\n */\nfunction getReadBuffer (buffer: Buffer, cursor: number, chunk: Buffer): Buffer {\n  const unreadBytes = getUnreadByteCount(buffer, cursor)\n  if (unreadBytes > 0) {\n    const newBuffer = Buffer.allocUnsafe(unreadBytes + chunk.length)\n    buffer.copy(newBuffer, 0, cursor)\n    chunk.copy(newBuffer, unreadBytes, 0)\n    return newBuffer\n  } else {\n    return chunk\n  }\n}\n\nfunction getUnreadByteCount (buffer: Buffer, cursor: number) {\n  return buffer.length - cursor\n}\n\n/**\n * Calculates the byte size of the next message that will be read from the buffer.\n *\n * If there is not enough data in the buffer to read a complete message it returns `undefined`\n *\n * @param buffer read buffer\n * @param cursor read cursor\n */\nfunction getMessageSize (buffer: Buffer, cursor: number): number | undefined {\n  const LENGTH_OFFSET = 9\n  const unreadByteCount = getUnreadByteCount(buffer, cursor)\n  if (unreadByteCount > LENGTH_OFFSET) {\n    const length = buffer[cursor + LENGTH_OFFSET]\n    if ((length & 0x80) === 0x80) {\n      if (unreadByteCount > (LENGTH_OFFSET + 1 + length)) {\n        const actualLength = buffer.readIntBE(cursor + LENGTH_OFFSET + 1, length)\n        if (unreadByteCount >= LENGTH_OFFSET + 1 + length + actualLength) {\n          return LENGTH_OFFSET + 1 + length + actualLength\n        }\n      }\n      return undefined\n    }\n    if (unreadByteCount >= LENGTH_OFFSET + 1 + length) {\n      return LENGTH_OFFSET + 1 + length\n    }\n  }\n  return undefined\n}\n"]}