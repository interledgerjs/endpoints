{"version":3,"file":"http-endpoint.js","sourceRoot":"","sources":["../src/http-endpoint.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport * as http from 'http2'\nimport * as url from 'url'\nimport * as net from 'net'\nimport * as tls from 'tls'\nimport { IlpPrepare, IlpReply, Errors as IlpErrors, IlpReject } from 'ilp-packet'\nimport { SError } from 'verror'\nimport { IlpEndpoint, RequestHandlerProvider } from './endpoint'\n\nexport const DEFAULT_MAX_TIMEOUT_MS = 5 * 60 * 1000\n\n/**\n * Constructor options for a new `IlpTransport` object.\n */\ninterface IlpTransportOptions {\n\n  /**\n   * The initial provider to use to provide a handler for incoming requests.\n   */\n  handlerProvider?: RequestHandlerProvider\n  /**\n   * The initial batch number to use\n   */\n  batch?: number\n  /**\n   * The time allowed after the batch changes when requests with the old batch will still be allowed.\n   */\n  batchCutoverTimeoutMs?: number\n  /**\n   * Max timeout allowed in ILP Prepare packets passed via `request`.\n   */\n  maxTimeoutMs?: number\n}\n\ninterface IlpHttpEndpointOptions extends IlpTransportOptions {\n  peerUrl: string | url.URL,\n  clientOptions?: http.ClientSessionOptions | http.SecureClientSessionOptions,\n  serverOptions: http.SecureServerOptions & { secure: boolean }\n}\n\n/**\n * Reference implementation of an IlpEndpoint using HTTP ILP as the underlying bilateral transport.\n */\nexport class IlpHttpEndpoint extends EventEmitter implements IlpEndpoint {\n  protected _server: http.Http2Server\n  protected _client: http.ClientHttp2Session\n  protected _maxTimeoutMs: number\n\n  /**\n   * Create a new IlpTransport using the provided server and client as the underlying transports stream.\n   *\n   * @param options constructor options\n   */\n  constructor (options: IlpHttpEndpointOptions) {\n    super()\n\n    this._maxTimeoutMs = (options && options.maxTimeoutMs)\n      ? options.maxTimeoutMs\n      : DEFAULT_MAX_TIMEOUT_MS\n\n    const createServer = options.serverOptions.secure ? http.createSecureServer : http.createServer\n    this._server = createServer(options.serverOptions, this._handleRequest.bind(this))\n    this._server.on('sessionError', (error: Error) => {\n      this.emit('error', new SError('error in underlying session', error))\n    })\n    this._client = http.connect(options.peerUrl, options.clientOptions)\n\n    if (options && options.handlerProvider) {\n      this.handlerProvider = options.handlerProvider\n    } else {\n      this.handlerProvider = (packet: IlpPrepare) => {\n        return (packet: IlpPrepare): Promise<IlpReply> => {\n          const err = new SError('no request handler for incoming request', packet)\n          this.emit('error', err)\n          return Promise.resolve({\n            triggeredBy: (this.address) ? this.address : 'peer',\n            code: IlpErrors.codes.T00_INTERNAL_ERROR,\n            message: '',\n            data: Buffer.allocUnsafe(0)\n          })\n        }\n      }\n    }\n  }\n\n  /**\n   * Function returning a `RequestHandler` given an incoming ILP Prepare.\n   *\n   * The default provider maintains a Map of handlers indexed by address prefixes. It finds the\n   * handler that has the longest prefix that matches the `destination` of the incoming packet.\n   */\n  public handlerProvider: RequestHandlerProvider\n\n  /**\n   * The ILP address of this endpoint. Used in ILP Reject messages generated by the transport.\n   */\n  public address?: string\n\n  public request (request: IlpPrepare, sentCallback?: (error?: Error) => void): Promise<IlpReply> {\n    if (!this._client) throw new Error('underlying stream is not writeable')\n\n    const timeoutMs = request.expiresAt.valueOf() - Date.now()\n    if (timeoutMs > this._maxTimeoutMs || timeoutMs <= 0) {\n      throw new SError('invalid expiresAt in ILP packet. timeoutMs=%s, maxTimeoutMs=%s', timeoutMs, this._maxTimeoutMs)\n    }\n    return new Promise<IlpReply>(async (replyCallback, errorCallback) => {\n      const timeout = setTimeout(() => {\n        // TODO - What to do with the request here?\n        errorCallback(new SError('timed out waiting for response'))\n      }, timeoutMs)\n\n      try {\n        const reply = await writeIlpHttpRequest(this._client, request, sentCallback)\n        clearTimeout(timeout)\n        replyCallback(reply)\n      } catch (e) {\n        errorCallback(e)\n      }\n    })\n  }\n\n  private _handleRequest (request: http.Http2ServerRequest, response: http.Http2ServerResponse): void {\n    readIlpHttpRequest(request)\n      .then(async (prepare) => {\n        const handler = this.handlerProvider(prepare)\n\n        let timedOut = false\n        const timeout = setTimeout(() => {\n          this.emit('error', new SError('timed out waiting for response from request handler. packet=%s', prepare))\n          timedOut = true\n        }, prepare.expiresAt.valueOf() - Date.now())\n\n        handler(prepare)\n        .then(reply => {\n          if (timedOut) {\n            this.emit('error', new SError('didn\\'t send fulfill as prepare had already timed out. packet=%s', reply))\n          } else {\n            clearTimeout(timeout)\n            try {\n              writeIlpHttpResponse(response, reply)\n            } catch (e) {\n              this.emit('error', new SError(e, 'error sending fulfill. packet=%s', reply))\n            }\n          }\n        })\n        .catch(e => {\n          // Error thrown by request handler\n          const err = new SError(e, 'error handling incoming request. packet=%', prepare)\n          this.emit('error', err)\n          const reply = {\n            triggeredBy: (this.address) ? this.address : 'peer',\n            code: IlpErrors.codes.T00_INTERNAL_ERROR,\n            message: '',\n            data: Buffer.allocUnsafe(0)\n          } as IlpReject\n          try {\n            writeIlpHttpResponse(response, reply)\n          } catch (e) {\n            this.emit('error', new SError(e, 'error sending reject. packet=%s', reply))\n          }\n        })\n      }).catch(e => {\n        this.emit('error', new SError(e, 'error reading request. request=%', request))\n      })\n  }\n}\n\nexport async function writeIlpHttpRequest (client: http.ClientHttp2Session, request: IlpPrepare, sentCallback?: (error?: Error) => void): Promise<IlpReply> {\n  if (sentCallback) sentCallback()\n  return {\n    fulfillment: Buffer.alloc(0),\n    data: Buffer.alloc(0)\n  }\n}\n\n// TODO - Based on content type, parse out the prepare packet\nexport async function readIlpHttpRequest (request: http.Http2ServerRequest): Promise<IlpPrepare> {\n  return {\n    amount: '',\n    destination: '',\n    executionCondition: Buffer.alloc(0),\n    expiresAt: new Date(),\n    data: Buffer.alloc(0)\n  }\n}\n\nexport function writeIlpHttpResponse (response: http.Http2ServerResponse, reply: IlpReply, sentCallback?: (error?: Error) => void): void {\n  // TODO\n  if (sentCallback) sentCallback()\n  response.setHeader('content-type', '')\n  response.write(reply.data, sentCallback)\n}\n"]}