{"version":3,"file":"ilp.js","sourceRoot":"","sources":["../src/ilp.ts"],"names":[],"mappings":";;AAAA,2CAA6K;AAC7K,uDAAyE;AAEzE,mCAAsD;AAOtD,SAAS,SAAS,CAAE,MAAW;IAC7B,OAAO,sBAAc,CAAC,MAAM,EAAE,SAAS,EAAE,OAAO,CAAC,CAAA;AACnD,CAAC;AAED,SAAS,SAAS,CAAE,OAAY;IAC9B,OAAO,sBAAS,CAAC,OAAO,CAAC,CAAA;AAC3B,CAAC;AAED,SAAS,OAAO,CAAE,KAAU;IAC1B,OAAO,sBAAS,CAAC,KAAK,CAAC,IAAI,qBAAQ,CAAC,KAAK,CAAC,CAAA;AAC5C,CAAC;AAED,SAAS,MAAM,CAAE,OAAe;IAC9B,OAAO,iCAAoB,CAAC,OAAO,CAAC,CAAC,IAAI,CAAA;AAC3C,CAAC;AAED,SAAS,MAAM,CAAE,OAAe;IAC9B,IAAI,sBAAS,CAAC,OAAO,CAAC,EAAE;QACtB,OAAO,gCAAmB,CAAC,OAAO,CAAC,CAAA;KACpC;IACD,IAAI,sBAAS,CAAC,OAAO,CAAC,EAAE;QACtB,OAAO,gCAAmB,CAAC,OAAO,CAAC,CAAA;KACpC;IACD,OAAO,+BAAkB,CAAC,OAAO,CAAC,CAAA;AACpC,CAAC;AAID,MAAa,iBAAkB,SAAQ,gCAAoC;IACzE,YAAa,OAAkC;QAC7C,KAAK,CAAC,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE,OAAO,CAAC,CAAA;IAC1D,CAAC;CACF;AAJD,8CAIC;AAMD,MAAa,4BAA4B;IAOvC,YAAa,QAAwC;QACnD,IAAI,QAAQ,EAAE;YACZ,KAAK,MAAM,CAAC,OAAO,EAAE,OAAO,CAAC,IAAI,QAAQ,EAAE;gBACzC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAA;aACpC;SACF;IACH,CAAC;IAUD,IAAW,cAAc;QACvB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;IAC/B,CAAC;IAED,IAAW,cAAc,CAAE,OAAqC;QAC9D,IAAI,OAAO,EAAE;YACX,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;SAChC;aAAM;YACL,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;SAC1B;IACH,CAAC;IAUM,KAAK,CAAC,aAAa,CAAE,OAAmB;QAC7C,IAAI,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;YAC1C,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,CAAA;YACtD,IAAI,OAAO;gBAAE,OAAO,OAAO,CAAC,OAAO,CAAC,CAAA;SACrC;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;QACtC,IAAI,OAAO;YAAE,OAAO,OAAO,CAAC,OAAO,CAAC,CAAA;QAEpC,MAAM,IAAI,KAAK,CAAC,0BAA0B,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAA;IACvE,CAAC;CACF;AArDD,oEAqDC","sourcesContent":["import { IlpPrepare, IlpReply, serializeIlpPrepare, isPrepare, isFulfill, isReject, deserializeIlpPacket, IlpAny, serializeIlpFulfill, serializeIlpReject } from 'ilp-packet'\nimport { StreamEndpoint, StreamEndpointOptions } from './stream-endpoint'\nimport { RequestHandler } from './request-stream'\nimport { isMessageFrame, MessageFrame } from './frame'\nimport { Endpoint } from './endpoint'\n\nexport type IlpRequestHander = RequestHandler<IlpPrepare, IlpReply>\n\nexport type IlpEndpoint = Endpoint<IlpPrepare, IlpReply>\n\nfunction isMessage (object: any): object is MessageFrame<IlpPrepare, IlpReply> {\n  return isMessageFrame(object, isRequest, isReply)\n}\n\nfunction isRequest (request: any): request is IlpPrepare {\n  return isPrepare(request)\n}\n\nfunction isReply (reply: any): reply is IlpReply {\n  return isFulfill(reply) || isReject(reply)\n}\n\nfunction decode (payload: Buffer): IlpAny {\n  return deserializeIlpPacket(payload).data\n}\n\nfunction encode (payload: IlpAny): Buffer {\n  if (isPrepare(payload)) {\n    return serializeIlpPrepare(payload)\n  }\n  if (isFulfill(payload)) {\n    return serializeIlpFulfill(payload)\n  }\n  return serializeIlpReject(payload)\n}\n\nexport type IlpStreamEndpointOptions = StreamEndpointOptions<IlpPrepare, IlpReply>\n\nexport class IlpStreamEndpoint extends StreamEndpoint<IlpPrepare, IlpReply> {\n  constructor (options?: IlpStreamEndpointOptions) {\n    super({ isMessage, isRequest, decode, encode }, options)\n  }\n}\n\n/**\n * A map of handlers than can be used as the RequestHandler for an `IlpEndpoint` where requests are passed to\n * different handlers depending on the ILP Address of the incoming packet.\n */\nexport class AddressMappedHandlerProvider {\n\n  /**\n   * Constructor\n   *\n   * @param handlers A Map of handlers to pre-load the object with.\n   */\n  constructor (handlers?: Map<string, IlpRequestHander>) {\n    if (handlers) {\n      for (const [address, handler] of handlers) {\n        this.handlers.set(address, handler)\n      }\n    }\n  }\n\n  /**\n   * The Map of handlers consulted when `handleRequest` is called.\n   */\n  public handlers: Map<string, IlpRequestHander>\n\n  /**\n   * The default handler provided when no match is found in the Map for the address of the request.\n   */\n  public get defaultHandler (): IlpRequestHander | undefined {\n    return this.handlers.get('*')\n  }\n\n  public set defaultHandler (handler: IlpRequestHander | undefined) {\n    if (handler) {\n      this.handlers.set('*', handler)\n    } else {\n      this.handlers.delete('*')\n    }\n  }\n\n  /**\n   * Provide the handler to use for the supplied packet.\n   *\n   * This implementation will return a handler from the backing Map using the address\n   * of the request as the key or the default handler if no match is found.\n   *\n   * @param request The incoming ILP packet that must be handled\n   */\n  public async handleRequest (request: IlpPrepare): Promise<IlpReply> {\n    if (request.destination.startsWith('peer')) {\n      const handler = this.handlers.get(request.destination)\n      if (handler) return handler(request)\n    }\n    const handler = this.handlers.get('*')\n    if (handler) return handler(request)\n\n    throw new Error('no handler for request. ' + JSON.stringify(request))\n  }\n}\n"]}